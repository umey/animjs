<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>MorphPath.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/FreezedMotionPath.html">FreezedMotionPath</a></li>
            
                <li><a href="..&#x2F;classes/Freezer.html">Freezer</a></li>
            
                <li><a href="..&#x2F;classes/MorphPath.html">MorphPath</a></li>
            
                <li><a href="..&#x2F;classes/MorphShape.html">MorphShape</a></li>
            
                <li><a href="..&#x2F;classes/MorphShapeBuilder.html">MorphShapeBuilder</a></li>
            
                <li><a href="..&#x2F;classes/MotionPath.html">MotionPath</a></li>
            
                <li><a href="..&#x2F;classes/Path.html">Path</a></li>
            
                <li><a href="..&#x2F;classes/QBezier.html">QBezier</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: MorphPath.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * MorphPath
 * MorphPath must be a &quot;closed-path&quot;
 *&#x2F;

(function(window){
&#x2F;**
 * @class MorphPath
 * @extends Path
 * @constructor
 **&#x2F;
var MorphPath = function (){
        MorphPath.__super__.constructor.apply(this, [0,0]);
};
&#x2F;&#x2F; extends Path
MorphPath.__super__ = Path.prototype;
var p = MorphPath.prototype = new Path();
&#x2F;&#x2F; static properties:
    &#x2F;**
     * Class name
     * @type {String}
     * @static
     * @const MorphPath.name
     *&#x2F;
    MorphPath.name = &quot;MorphPath&quot;;

&#x2F;&#x2F; private method
    &#x2F;**
     * calc interpolate pos
     * @method
     * @param {Point} p0
     * @param {Point} p1
     * @param {Number} t
     * @return {Point}
     * @private
     *&#x2F;
    p._interpolate = function(p0,p1,t){
        var tx = p1.x-p0.x;
        var ty = p1.y-p0.y;
        var x,y;
        if(tx===0){
            x = p0.x;
            y = p0.y+ty*t;
        }else{
            var a = ty&#x2F;tx;
            x = p0.x+tx*t;
            y = p0.y+tx*t*a;
        }
        x = ((x*10)|0)&#x2F;10;
        y = ((y*10)|0)&#x2F;10;
        return new Point(x, y);
    };

&#x2F;&#x2F; public method:
    &#x2F;**
     * calc rectangle
     * @method getRect
     * @return {Object} top.left,width,height (rectangle Object)
     *&#x2F;
    p.getRect = function(){
        var top,left,right,bottom, t,tt;
        var x0,y0,x1,y1,x2,y2,tmp;
        var data = this.pointList;
        top=bottom = data[1];
        right=left = data[0];
        for(var i = 0;i&lt;data.length-2;i+=Path.BLOCK_COUNT){
            x0 = data[i];
            x1 = data[i+2];
            x2 = data[i+4];
            right = Math.max(right,x0,x2);
            left = Math.min(left,x0,x2);
            t = (x0-x1)&#x2F;(x2-2*x1+x0);
            if(0 &lt;= t &amp;&amp; t &lt;= 1){
                tt = 1-t;
                tmp = tt*tt*x0+2*tt*t*x1+t*t*x2;
                if(left&gt;tmp){
                    left = tmp;
                }else if(tmp&gt;right){
                    right = tmp;
                }
            }
        }
        for(i = 0;i&lt;data.length-2;i+=Path.BLOCK_COUNT){
            y0 = data[i+1];
            y1 = data[i+3];
            y2 = data[i+5];
            bottom = Math.max(bottom,y0,y2);
            top = Math.min(top,y0,y2);
            t = (y0-y1)&#x2F;(y2-2*y1+y0);
            if(0 &lt;= t &amp;&amp; t &lt;= 1){
                tt = 1-t;
                tmp = tt*tt*y0+2*tt*t*y1+t*t*y2;
                if(top&gt;tmp){
                    top = tmp;
                }else if(bottom&lt;tmp){
                    bottom = tmp;
                }
            }
        }
        return {top:top, left:left, width:right-left, height:bottom-top};
    };
    &#x2F;**
     * translate x,y pos to specified point.
     * @method translate
     * @param {Number} x
     * @param {Number} y
     *&#x2F;
    p.translate = function(x,y){
        var data = this.pointList;
        for(var i=0;i&lt;data.length;i+=2){
            data[i]-=x;
            data[i+1]-=y;
        }
    };
    &#x2F;**
     * calc data
     * @method calculate
     *&#x2F;
    p.calculate = function(){
        if(this._dirty = true)this._calc();
    };
    &#x2F;**
     * split the path at specified time
     * @param {Number} time animation time
     *&#x2F;
    p.splitAt = function(time){
        if(time===0 || time == this.time)return;
        var info = this.getAt(time);
        var t = info.t;
        var qb = info.qb;

        var np = qb.getAt(t);
        var cp0 = this._interpolate(qb.p0,qb.p1,t);
        var cp1 = this._interpolate(qb.p1,qb.p2,t);
        var ttIndex = info.ttIndex;

        var dataIndex = 2 + Path.BLOCK_COUNT*ttIndex;
        this.length++;
        this.pointList.splice(dataIndex,2,cp0.x,cp0.y,np.x,np.y,cp1.x,cp1.y);
        var currentObj = this._timeTable[ttIndex];
        var tmpTime = currentObj.dist;
        currentObj.dist*=(1-t);
        this._timeTable.splice(ttIndex,0,{time:time, dist:tmpTime-currentObj.dist});
    };
    &#x2F;**
     * sort point data by the two specified point
     * search the nearest anchor to the first point, and set the direction by next point.
     * and sort data.
     * @method sortByPoint
     * @param {Number} x0 first point x
     * @param {Number} y0 first point y
     * @param {Number} x1 next point x
     * @param {Number} y1 next point y
     *&#x2F;
    p.sortByPoint = function(x0,y0,x1,y1){
        this.calculate();
        var distance = function(x0,y0,x1,y1){
            var dx = x1-x0;
            var dy = y1-y0;
            return Math.sqrt(dx*dx+dy*dy);
        };
        var data = this.pointList;
        var tTable = this._timeTable;
        var len = data.length;
        data.splice(len-2,2);
        len-=2;

        var lastObj = tTable[tTable.length-1];
        this.totalDist -= lastObj.dist;
        lastObj.dist = new QBezier(new Point(data[0],data[1]),new Point(data[len-2],data[len-1]), new Point(data[len-4],data[len-3])).getDistance();
        this.totalDist += lastObj.dist;

        var headIndex = 0;
        var nearest = distance(x0,y0,data[0],data[1]);
        var v;
        for(var i=4;i&lt;data.length;i+=Path.BLOCK_COUNT){
            v = distance(x0,y0,data[i],data[i+1]);
            if(v&lt;nearest){
                nearest=v;
                headIndex = i;
            }
        }
        var tIndex = headIndex&#x2F;4;

        var direction = 1;
        var next = distance(x1,y1,data[headIndex+4],data[headIndex+5]);
        var prev = (headIndex-4&lt;0)? distance(x1,y1,data[data.length-6],data[data.length-5]) :distance(x1,y1,data[headIndex-4],data[headIndex-3]);
        if(prev&lt;next)direction = -1;

        data.splice(headIndex,0,data[headIndex],data[headIndex+1]);
        len+=2;
        headIndex+=(direction+1)&#x2F;2*2;
        var newData = [];
        var tmpIndex = headIndex;
        for(i=0;i&lt;len;i+=2){
            newData.push(data[tmpIndex],data[tmpIndex+1]);
            tmpIndex += len+2*direction;
            tmpIndex%=len;
        }
        this.pointList = newData;
        var newTimeTable = [];
        len = tTable.length;
        tmpIndex = (len+tIndex+(direction-1)&#x2F;2)%len;
        for(i=0;i&lt;len;i++){
            newTimeTable.push(tTable[tmpIndex]);
            tmpIndex += len+direction;
            tmpIndex%=len;
        }
        this._timeTable = newTimeTable;
        this._calc();
    };
    &#x2F;**
     * set fill color
     * @method beginFill
     * @param {Number|String} color
     * @return {Path}
     *&#x2F;
    p.beginFill = function(color){
        return this.beginStroke(color);
    };
    &#x2F;**
     * shortcut to &quot;beginFill&quot;
     * @method f
     * @param {Number|String} color
     * @return {Path}
     *&#x2F;
    p.f = function(color){
        return this.beginStroke(color);
    };
    &#x2F;**
     * read anchor-contlol-anchor data from the array
     * @method read
     * @param {Array}arr
     *&#x2F;
    p.read = function(arr){
        this.moveTo(arr[0],arr[1]);
        for(var i=2;i&lt;arr.length-2;i+=Path.BLOCK_COUNT){
            this.push(arr[i],arr[i+1],arr[i+2],arr[i+3]);
        }
    };
    window.MorphPath = MorphPath;
})(window);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
